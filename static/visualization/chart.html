

    <script type='text/javascript' src='http://www.google.com/jsapi'></script>
    <script type="text/javascript"
        src='https://www.google.com/jsapi?autoload={"modules":[{"name":"visualization","version":"1"}]}'>
    </script>

    <script type="text/javascript" src="http://code.jquery.com/jquery-1.9.0.min.js"></script>
    <script type="text/javascript" src="http://code.jquery.com/ui/1.10.0/jquery-ui.min.js"></script>
    <script type="text/javascript" src="js/spin.js" ></script>

    <link rel="stylesheet" media="all" type="text/css" href="http://code.jquery.com/ui/1.10.0/themes/smoothness/jquery-ui.css" />
    <!-- <link rel="stylesheet" media="all" type="text/css" href="/static/css/dark.css" /> -->
    
    <link href='http://fonts.googleapis.com/css?family=Signika:300,400,600,700' rel='stylesheet' type='text/css'/>
    <link href='http://fonts.googleapis.com/css?family=Signika+Negative:300,400,600,700' rel='stylesheet' type='text/css' />
    

    <!-- High charts / High stocks -->
    <script src="js/highstock/js/highstock.js"></script>
    <script src="js/highstock/js/modules/exporting.js"></script>
    
    <style> 
      .container {
        /* border:2px solid #ccc;*/ 
        /*width:300px;*/
        height: 100px; 
        overflow-y: scroll; 
/*        margin-bottom: 5px;*/
      }
      
      .chart-type {
        border-top: solid 1px #444;
        border-bottom: solid 1px #444;
        padding: 7px 0;
        margin: 7px 0;
      }
      
      .chart-type select {
        color: #fff;
        background-color: #444;
        -webkit-appearance: menulist;
        box-sizing: border-box;
        -webkit-box-align: center;
        border: 1px solid #333;
/*        border-image: initial;*/
        white-space: pre;
        -webkit-rtl-ordering: logical;
        color: black;
        background-color: white;
        cursor: default;
      }
      
      
      #chart_ui_div {
        color: #333;
        background-color: #f4f4f4;
        font-family: Signika;
        font-size: 11px;
      }
      
      
      #chart_ui_div input {
        color: #333; 
        font-size: 10px; 
        font-weight: 600; 
        padding: 4px;
        margin: 0 5px;
        text-decoration: none; 
        text-shadow: 1px 1px 1px #FFFFFF;

        -webkit-border-radius: 3px; 
        -moz-border-radius: 3px; 
        border-radius: 3px;
        border-top:#FFFFFF 1px solid;
        border-left:#FFFFFF 1px solid;
        border-right:#7D7D7D 1px solid;
        border-bottom:#7D7D7D 1px solid;

        background: #ebebeb;
        background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEgMSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkLXVjZ2ctZ2VuZXJhdGVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iI2ViZWJlYiIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjUwJSIgc3RvcC1jb2xvcj0iI2NkY2RjZCIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiNiOWI5YjkiIHN0b3Atb3BhY2l0eT0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0idXJsKCNncmFkLXVjZ2ctZ2VuZXJhdGVkKSIgLz4KPC9zdmc+);
        background: -moz-linear-gradient(top,  #ebebeb 0%, #cdcdcd 50%, #b9b9b9 100%);
        background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#ebebeb), color-stop(50%,#cdcdcd), color-stop(100%,#b9b9b9));
        background: -webkit-linear-gradient(top,  #ebebeb 0%,#cdcdcd 50%,#b9b9b9 100%);
        background: -o-linear-gradient(top,  #ebebeb 0%,#cdcdcd 50%,#b9b9b9 100%);
        background: -ms-linear-gradient(top,  #ebebeb 0%,#cdcdcd 50%,#b9b9b9 100%);
        background: linear-gradient(to bottom,  #ebebeb 0%,#cdcdcd 50%,#b9b9b9 100%);
        filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ebebeb', endColorstr='#b9b9b9',GradientType=0 );
      }
    </style>

    <script type='text/javascript'>

    /*
     NOTE : The caching of the datatable is pretty basic and essentially amount to storing a set
     number of retrieves on the browser side and generating an appropriate dataview from the
     data. If certain data is not available, then a call to the viz service is made.

     [1] The cache is currently disabled. The overview data is fetched at page load and then as the user
     moves around, hi-res data is appropriately fetched and merged into the overview. The realtime data blocks
     are also stored separatelt and merged. For the sake of required functionality, the three blocks are kept
     separate and updated when needed. However before updating the chart, the three types (overview, hi-res and realtime)
     are merged everytime. This is an expensive operation and needs to be corrected as its not scalable.

     [2] The stride_factor and zoom factor are used interchangeably. When stride_factor reduces ( ..3,2,1) the
     data resolution increases and there fore the zoom increases. So zoom = 1 is the highest and subsequent levels
     zoom out.

     */

    // Global variables
    var chart, table, dataTable, dataTable_overview, dp_id, dp_metadata;
    var data_series_overview, data_series_hires, data_series_rt;

    var data_overview_stride_factor = 1;
    var chart_visible_start_date, chart_visible_end_date, chart_x_res, avg_data_rate, curr_stride_factor = 1;
    var dp_parameters = []; // ['temp', 'pressure', 'conductivity'];
    var curr_parameter_visibility = {};
    var precisions = {};
    var display_names = {};
    var display_names_reverse = new Object();

    var container_server =  "http://" + window.location.host;

    // Realtime variables
    var enable_realtime = true; // Glabal switch to control realtime controls
    var rt_query, rt_query_token, rt_len_max;
    var realtime_sticky_view = true;
    var setExtremesMethodFlag = false;

    // Chart options
    var curr_timezone = 0, curr_timezone_display=" UTC";
    var max_supported_parameters_rt = 50;
    var curr_chart_type = "line";
     var curr_output_type = ".htmlTable";
    var curr_y_axis_compare_type = undefined;
    //var supported_chart_type = ['AnnotatedTimeLine', 'Table', 'LineChart', 'AreaChart', 'ComboChart'];
    var supported_chart_type = ['line', 'area', 'spline', 'scatter', 'table'];
    var supported_output_type = ['.htmlTable', '.csv', '.nc', '.json', '.asc', '.ncHeader', '.mat'];
    var overview_reqId = 9;
    var chart_spinner, spin_target;

    var chartBkgColor;
    var chartLabelColor;
    var chartLabelInactiveColor;
    var chartLabelHoverColor;
    var chartSeriesColor;
    /*
    chartBkgColor = "#231F20";
    chartLabelColor = "#FFFFFF";
    chartLabelInactiveColor = "#999999";
    chartLabelHoverColor = "#888822"
    chartSeriesColor = ["#1f75fe",
        "#f9fa47",
        "#fd524b",
        "#fca767",
        "#8bce6d",
        "#71dab9",
        "#1792bb",
        "#926eae",
        "#fe62ac",
        "#185fc7",
        "#cbc440",
        "#ce4138",
        "#c98554",
        "#6da659",
        "#56b094",
        "#0b7895",
        "#4c72a3",
        "#74588b",
        "#c3538b"
    ];
    */

    // Google library specific loads for all the supported chart types
    google.load("visualization", "1", {packages: ['table']});
    google.setOnLoadCallback(initChart);

    function initChart() {

        dp_id = parent.window.location.pathname.split('/')[3]

        // prompt user for dp id if none was passed in the url
        if (dp_id == null || dp_id.length <32) {
            dp_id=prompt("Please enter Data Product Id","");
            if (dp_id == null) return;
        }

        console.log('dp_id: ', dp_id);

        //  Set additional page events here
        window.addEventListener("beforeunload", chartCleanup, false);
        document.getElementById('chart_div').align = "center";
        document.getElementById('chart_div').style.verticalAlign = "middle";

        // Init some variables
        chart_x_res = document.getElementById("chart_div").scrollWidth;
        data_series_hires = [];
        data_series_rt = [];
        initSpinner();
        spin_target = document.getElementById('chart_div');

        console.log("parent.IONUX.SESSION_MODEL.get('ui_theme_dark')", parent.IONUX.SESSION_MODEL.get('ui_theme_dark'));

        // init theme colors
        if (parent.IONUX.SESSION_MODEL.get('ui_theme_dark')) {
            chartBkgColor = "#231F20";
            chartLabelColor = "#FFFFFF";
            chartLabelInactiveColor = "#999999";
            chartLabelHoverColor = "#888822"
            chartSeriesColor = ["#1f75fe",
                "#f9fa47",
                "#fd524b",
                "#fca767",
                "#8bce6d",
                "#71dab9",
                "#1792bb",
                "#926eae",
                "#fe62ac",
                "#185fc7",
                "#cbc440",
                "#ce4138",
                "#c98554",
                "#6da659",
                "#56b094",
                "#0b7895",
                "#4c72a3",
                "#74588b",
                "#c3538b"
            ];
        }
        else {
            // Assume its the salt theme. Set all variables to null to let the chart default to its basic theme
            chartBkgColor = "#f4f4f4";
            chartLabelColor = "#000000";
            chartLabelInactiveColor = "#999999";
            chartLabelHoverColor = chartSeriesColor = null;
        }

        // Init the overview chart
        chart = table = null;
        initOverview();

        rt_len_max = 300;

    }

    function initOverview() {

        dataTable_overview = null
        data_series_overview = [];

        /// Get meta data for the data product id. It will be used to retrieve the correct data
        var dqp = setDataQueryParams("metadata", null, null, null, null);

        jQuery.ajax ({
            url: container_server + "/visualization/get_visualization_data/?data_product_id=" + dp_id +
                    "&visualization_parameters=" + encodeURIComponent(JSON.stringify(dqp)),
            dataType: 'json',
            success: dp_metadata_cb,
            error: function(jqXHR, status, err_type) {
                console.debug("Error retrieving metadata for the data_product : " + jqXHR.responseText);
                document.getElementById('chart_div').innerHTML = "Error retrieving metadata for the data product.";
            }
        });

    }

    function dp_metadata_cb(response, textStatus, jqXHR) {

        if (response == null) {
            document.getElementById('chart_div').innerHTML = "No Data Available.";
            stopRealtimeView();
            return;
        }
        if(response["data"]) {
            dp_metadata = jQuery.parseJSON(response["data"]);
        }
        else {
            document.getElementById('chart_div').innerHTML = "No Data Available.";
            console.debug("Error: Did not receive metadata for the dataproduct");
            stopRealtimeView();
            return;
        }

        // If the metadata indicates that the product had a processing_level of 'raw', no need to proceed
        if('processing_level_code' in dp_metadata &&
                dp_metadata['processing_level_code'].toLowerCase() == "raw") {
            document.getElementById('chart_div').innerHTML = "This data product can not be visualized.";
            stopRealtimeView();
            return;
        }

        // Check to see if valid metadata was returned
        if (dp_metadata['time_steps'] < 1 || dp_metadata['time_bounds'][0] == -9999.0 || dp_metadata['time_bounds'][1] == -9999.0) {
            document.getElementById('chart_div').innerHTML = "No data available.";
            stopRealtimeView();
            return;
        }

        display_names = dp_metadata['parameter_display_names'];

        // calculate and init a few things
        avg_data_rate = dp_metadata['time_steps'] / (dp_metadata['time_bounds'][1] - dp_metadata['time_bounds'][0]);

        // calculate the stride factor
        var num_of_actual_data_points = (dp_metadata['time_bounds'][1] - dp_metadata['time_bounds'][0]) * avg_data_rate;
        data_overview_stride_factor = Math.ceil(num_of_actual_data_points / chart_x_res);

        var dqp = setDataQueryParams("highcharts_data", dp_parameters, dp_metadata['time_bounds'][0], dp_metadata['time_bounds'][1], data_overview_stride_factor);
        fetchData(dqp);
    }


    function fetchData(dqp) {

        var query;

        jQuery.ajax ({
            url: container_server + "/visualization/get_visualization_data/?data_product_id=" + dp_id +
                    "&visualization_parameters=" + encodeURIComponent(JSON.stringify(dqp)),
            dataType: 'json',
            success: handleDataQueryResponse,
            error: function(jqXHR, status, err_type) {
                document.getElementById('chart_div').innerHTML = "Error retrieving data for plotting.";
                chart_spinner.stop();
                console.debug("Error retrieving data for the data_product : " + jqXHR.responseText);
            }
        });

        // Starter the spinner to tell user that more data is coming
        chart_spinner.spin(spin_target);

    }


    function handleDataQueryResponse(response) {

        var i, tempData;
        // Stop the spinner
        chart_spinner.stop();

        // Check if null was returned
        if (response["data"]) {
            var _dt = jQuery.parseJSON(response["data"].replace(/\bNaN\b/g, "null"));
        }
        else {
            document.getElementById('chart_div').innerHTML = "No Valid Data Available.";
            stopRealtimeView();
            return;
        }

        // If an empty data table was returned, exit gracefully
        if (_dt.length == 0 || _dt[0].length == 0) {
            if(data_series_overview.length == 0){
                document.getElementById('chart_div').innerHTML = "No data was found in storage. Please try again in a bit";
                stopRealtimeView();
            }

            console.debug("Data query returned an empty set.");
            return;
        }

        // replace names with display names
        use_display_names_in_data(_dt);
        // This would be a good place to sort wrt timestamps if ever needed

        // If the overview series is empty, assume this is the response to the overview query
        if (data_series_overview.length == 0) {
            data_series_overview = _dt;

            // Remove series that were marked visible == false. probably string content
            remove_unchartable_hc_data(data_series_overview);
            // Check to see if there is ay valid plot-table data
            if (data_series_overview == null || data_series_overview.length == 0 ) {
                document.getElementById('chart_div').innerHTML = "No Valid Data Available.";
                stopRealtimeView();
                return;
            }

            // If no chart exists, create one. If one exist, redraw and reset the view
            if(chart) {
                drawChart(true, mergeAndSortHcData(data_series_overview, data_series_hires, data_series_rt));
            }
            else{
                drawChart(true, mergeAndSortHcData(data_series_overview, null, null));
                // Create the UI at this point. Now that we have the data
                initChartUi();
            }

            // Edge case for the end of the data when the last point in the low-res data does
            // not correspond to the actual data limits (limitation of stride). In this case we do
            // a special fetch to fill in the last bit with hi-res data
            var last_overview_ts = data_series_overview[0]["data"][data_series_overview[0]["data"].length - 1][0] / 1000;
            if (last_overview_ts < dp_metadata['time_bounds'][1] ) {
                var dqp = setDataQueryParams("highcharts_data", dp_parameters,
                        last_overview_ts, dp_metadata['time_bounds'][1], 1);
                fetchData(dqp);
            }
        }
        // Otherwise its data that needs to replace what's currently in the chart
        else {
            data_series_hires = _dt;
            drawChart(false, mergeAndSortHcData(data_series_overview, data_series_hires, data_series_rt));
        }

    }


    function highcharts_to_gdt (_hc_data) {
        var gdt = new google.visualization.DataTable();
        var var_type, i, j;

        // Make sure the first column is the time stamp
        gdt.addColumn("datetime", "Timestamp (" + curr_timezone_display + ")")

        // Create the columns first
        for (i = 0; i<_hc_data.length; i++) {
            // Assume type is number unless otherwise
            if (_hc_data[i]["data"].length == 0 && _hc_data[i]["visible"] == false) {
                var_type = "string";  // this is a guess
            }

            if (_hc_data[i]["data"].length > 0) {
                var_type = typeof(_hc_data[i]["data"][0][1]);
            }

            if (var_type != "string") {
                var_type = "number";
            }

            // At this point var_type is either a string or a number only
            gdt.addColumn(var_type, _hc_data[i]["name"])
        }

        // Now populate the rows.
        var temp_tuple = [];
        for (var i = 0; i<_hc_data[0]["data"].length; i++) {
            temp_tuple = [];

            // Fill the time field from the timestamp of the first parameter. Not exactly robust.
            temp_tuple.push(new Date(_hc_data[0]["data"][i][0]))

            for (j = 0; j < _hc_data.length; j++) {
                temp_tuple.push(_hc_data[j]["data"][i][1]);
            }
            gdt.addRow(temp_tuple);
        }

        return gdt;
    }

    // Array Remove - By John Resig (MIT Licensed)
    Array.prototype.remove = function(from, to) {
        var rest = this.slice((to || from) + 1 || this.length);
        this.length = from < 0 ? this.length + from : from;
        return this.push.apply(this, rest);
    };

    function remove_unchartable_hc_data(_hc_data) {
        for (var i = 0; i<_hc_data.length; i++) {
            if (_hc_data[i]['visible'] == false) {
                _hc_data.remove(i);
                --i;
                continue;
            }
        }
    }

    function use_display_names_in_data(_hc_data) {

         var a = new Object();

        var name;
        for (var i = 0; i<_hc_data.length; i++) {
            name = _hc_data[i]["name"];
            if ((name in display_names) && (display_names[name] != "")) {
                _hc_data[i]["name"] = display_names[name];
                display_names_reverse[display_names[name]] = name;
            }
        }
    }

    // Typically used to merge overview, realtime and high-res in to one series before drawing. Assumption
    // is that the overview data is valid when this function is called. This is a very expensive function
    // since it not only makes copies of all the data series passed to it, it is called every time the chart
    // needs to be updated with new data.
    function mergeAndSortHcData(ov_data, hr_data, rt_data) {

        var _hc_data = ov_data.slice();
        //var _hc_data = jQuery.extend(true, [], ov_data);
        var tempIdx = 0;
        var tempCount = 0;

        // Merge the overview and hi-res and then the real-time
        for (var i = 0; i<_hc_data.length; i++) {

            // Merge overview and hi-res. Before concatenating make sure the arrays match.
            if (hr_data != null) {
                tempIdx = -1;
                for (var j = 0; j < hr_data.length; j++) {
                    tempCount = (i + j) % hr_data.length;
                    if(_hc_data[i]["name"] == hr_data[tempCount]["name"]) {
                        tempIdx = tempCount;
                        break;
                    }
                }

                if (tempIdx >= 0) {
                    _hc_data[i]["data"].push.apply(_hc_data[i]["data"], hr_data[tempIdx]["data"]);
                }
            }

            // Similarly merge real-time
            if(rt_data != null) {
                tempIdx = -1;
                for (var j = 0; j < rt_data.length; j++) {
                    tempCount = (i + j) % rt_data.length;
                    if(_hc_data[i]["name"] == rt_data[tempCount]["name"]) {
                        tempIdx = tempCount;
                        break;
                    }
                }

                if (tempIdx >= 0) {
                    _hc_data[i]["data"].push.apply(_hc_data[i]["data"], rt_data[tempIdx]["data"]);
                }
            }
        }

        // Now that the merge is complete, sort the data series since they were not merged in order
        // now sort all the series wrt to time before drawing
        for (var i = 0; i<_hc_data.length; i++) {
            _hc_data[i]["data"].sort(function(a,b){
                return a[0] - b[0];
            })
        }

        return _hc_data;
    }

    function getNormalizedName(name) {

        if ((name in display_names) && (display_names[name] != "")) {
            return display_names[name];
        }
        else {
            return name;
        }
    }

    // This function is supposed to take care of a few cases. It draws the chart for the first time (overview) and then
    // also handles when the high-res updates are merged with the overview.

    // *** THIS FUNCTION WILL MODIFY THE ORIGINAL DATA. PASS ONLY COPIES ***
    function drawChart(_first_draw_flag, _data) {

        var plotMarkerOptions = null;
        var plotLineWidth = null;
        var normalizedChartType = curr_chart_type;

        // Occasionally an empty data set slips in
        if (_data == null || _data.length == 0 ) return;

        // Handle tables in a special way
        if (curr_chart_type == 'table') {

            if (dataTable_overview == null) {
                // Convert the hc data to gdt. This is a lazy behaviour
                dataTable_overview = highcharts_to_gdt(_data);
            }

            drawTable(dataTable_overview);
            return;
        }

        // Override the options for scatter plot with our own. Default has bugs
        if (curr_chart_type == 'scatter') {
            normalizedChartType = 'line';
            plotMarkerOptions = {
                enabled : true,
                radius : 3
            };

            plotLineWidth = 0;
        }
        else {
            plotMarkerOptions = {
                enabled: false,
                        states: {
                    hover: {
                        enabled: true
                    }
                }
            };

            plotLineWidth = 2;
        }

        // ** Big Assumption **: Since we are working on a copy of the data (returned by mergeAndSortHcData)
        // its ok to modify it and strip all strings from it
        remove_unchartable_hc_data(_data);

        // Create the chart if the call is being called for the first time
        if (_first_draw_flag) {

            if(chart && chart != undefined) {
                chart.destroy();
            }

            chart = new Highcharts.StockChart({
                chart : {
                    renderTo : 'chart_div',
                    type: normalizedChartType,
                    backgroundColor: chartBkgColor,
                    borderColor: "black",
                    zoomType: "x"
                },
                credits: {
                    enabled: false
                },
                /*
                 title : {
                 text : 'Overview Chart'
                 },
                 */
                color: chartSeriesColor,

                navigator : {
                    adaptToUpdatedData: false,
                    series : {
                        //data : _data[0]["data"],

                        labels: {
                            style : {
                                color : chartLabelColor
                            }
                        }
                    }
                },

                legend: {
                    enabled: true,
                    align: 'right',
                    backgroundColor: chartBkgColor,
                    borderColor: chartBkgColor,
                    layout: 'vertical',
                    verticalAlign: 'top',
                    y: 50,

                    itemStyle : {
                        color : chartLabelColor
                    },
                    itemHiddenStyle : {
                        color : chartLabelInactiveColor
                    },
                    itemHoverStyle : {
                        color : chartLabelHoverColor
                    }

                },

                xAxis: {
                    labels: {
                        style : {
                            staggerLines: 2,
                            color : chartLabelColor
                        }
                    },
                    type: 'datetime',
                    title: {
                        text: 'Time (' + curr_timezone_display + ')'
                    },
                    events : {
                        afterSetExtremes : onDateRangeChange
                    },
                    startOnTick: false,
                    endOnTick: false,
                    showLastLabe: false,
                    min: dp_metadata['time_bounds'][0] * 1000,
                    max: dp_metadata['time_bounds'][1] * 1000,
                    minRange: 5  // 5 points at max
                },

                yAxis: {
                    labels: {
                        formatter: function() {
                            return (this.value >= 0 ? '+' : '') + this.value + (curr_y_axis_compare_type == "percent" ? '%' : '');
                        },
                        style : {
                            color : chartLabelColor,
                            fontWeight: 'bold'
                        }
                    },
                    plotLines: [{
                        value: 0,
                        width: 2,
                        color: 'silver'
                    }],
                    showFirstLabel: true,
                    showLastLabel: true,
                    offset: 40
                },

                tooltip: {
                    shared: true,
                    /*formatter: function() {
                        var d = new Date(this.x);
                        return d.getDay() + ", " + d.getDate() + ", " + d.getHours() + ":" + d.getMinutes() +':'+ d.getSeconds()
                                +'.' + d.getMilliseconds();
                    }*/
                    xDateFormat: '%d-%b-%Y, %H:%M:%S.%L' + curr_timezone_display
                },

                plotOptions: {
                    series: {
                        compare: curr_y_axis_compare_type,
                        connectNulls: false,
                        events: {
                            hide: function() {
                                curr_parameter_visibility[this.name] = false;
                            },
                            show: function() {
                                curr_parameter_visibility[this.name] = true;
                            }
                        },
                        dataGrouping: {
                            enabled: true
                        },
                        marker: plotMarkerOptions,
                        lineWidth : plotLineWidth
                    },
                    threshold: null
                },
                exporting: {
                    width:  chart_x_res
                },

                rangeSelector : {
                    inputStyle: {
                        color: '#888888',
                        fontWeight: 'bold',
                        background: '#FFFFFF'
                    },

                    buttons: [{
                        type: 'minute',
                        count: 1,
                        text: '1\''
                    },{
                        type: 'hour',
                        count: 1,
                        text: '1h'
                    }, {
                        type: 'day',
                        count: 1,
                        text: '1d'
                    }, {
                        type: 'month',
                        count: 1,
                        text: '1m'
                    }, {
                        type: 'year',
                        count: 1,
                        text: '1y'
                    }, {
                        type: 'all',
                        text: 'All'
                    }],
                    inputEnabled: true, // it supports only days
                    selected : 5, // all

                    buttonTheme: { // styles for the buttons

                        states: {
                            hover: {
                            },
                            select: {
                                style: {
                                    color: 'white'
                                }
                            }
                        }
                    }
                },

                series : _data
            });

        }
        // If it was not a first draw, it was the higher res data
        else {

            var i, view_window_width = chart.xAxis[0].getExtremes().max - chart.xAxis[0].getExtremes().min;

            // note the view extremes and reset after the chart has been drawn. Also find the longest series
            // since not all are the same length.
            var longest_series_idx = 0;
            var longest_series_length = 0;
            for (i=0; i < _data.length; i++) {
                chart.series[i].setData(_data[i]["data"], false);

                if (_data[i]["data"].length > longest_series_length) {
                    longest_series_length = _data[i]["data"].length;
                    longest_series_idx = i;
                }
            }

            // update the navigator series .. its the last one
            chart.series[chart.series.length - 1].setData(_data[0]["data"], false);


            // now if the realtime_sticky_view is enabled, adjust the x axis range to reflect this
            if (realtime_sticky_view) {

                var xaxis_view_max = _data[longest_series_idx]["data"][_data[longest_series_idx]["data"].length - 1][0];
                var xaxis_view_min = xaxis_view_max - view_window_width;

                setExtremesMethodFlag = true;
                chart.xAxis[0].setExtremes(xaxis_view_min, xaxis_view_max, false);
            }

            chart.redraw();
        }

        // update series visibility
        if(curr_chart_type != 'scatter') {
            updateSeriesVisibility();
        }

    }

    function drawTable(_data) {

        if (table) { delete table;}
        $("#chart_div").empty();

        // Apply a date formatter to the first column to convert to UTC timezone..
        // Apparently google charts ignores time zone by default
        var df = new google.visualization.DateFormat({formatType: 'long', timeZone:curr_timezone});
        df.format(_data, 0);

        table = new google.visualization.Table(document.getElementById('chart_div'));
        table.draw(_data, {allowHtml:true});
    }


    function updateSeriesVisibility() {
        if(!chart) return;

        // check visibility flags for all the series
        for (var i = 0; i < chart.series.length - 1; i++) {

            // if the entry in the visibility dict does not exist, create it
            if (chart.series[i]["name"] in curr_parameter_visibility) {
                if (curr_parameter_visibility[chart.series[i]["name"]]) {
                    chart.series[i].show();
                }
                else {
                    chart.series[i].hide();
                }
            }
            else {
                curr_parameter_visibility[chart.series[i]["name"]] = true;
                chart.series[i].show();
            }
        }
    }


    // When this function is called, it is assumed that the annotated timeline chart object has already been created
    function initRealtimeView() {

        data_series_rt = [];
        // In case the page was refreshed, check to see if a query token exists and call cleanup on it
        if (rt_query_token) {
            stopRealtimeView();
        }

        // Init the realtime queues and pipeline on the container
        jQuery.ajax ({
            url: container_server + "/visualization/initiate_realtime_visualization_data/?data_product_id=" + dp_id,
            dataType: 'json',
            success: initRealtimeViewCb,  // Has to correspond with the server side response
            error: function(jqXHR, status, err_type) {
                console.debug("Error retrieving token for realtime queue: " + jqXHR.responseText);
                alert("Could not start real-time view. Are you logged in ?");
            }
        });

    }

    function initRealtimeViewCb(resp, textStatus, jqXHR ) {

        if (!resp) {
            console.debug("Not a valid query token. Will not show real-time data.");
            return;
        }

        rt_query_token = jQuery.parseJSON(resp['data'])['rt_query_token'];
        console.debug ("Query Token : " + rt_query_token);


        // Make a query for realtime update and set it to repeat every X millisecs
        rt_query = setInterval(function(){
            jQuery.ajax ({
                url: container_server + "/visualization/get_realtime_visualization_data/?query_token=" + rt_query_token,
                dataType: 'json',
                success: handleRealtimeQueryResponse,  // Has to correspond with the server side response
                error: function(jqXHR, status, err_type) {
                    console.debug("Error retrieving data for realtime updates: " + jqXHR.responseText);
                    stopRealtimeView();
                }
            });
        }, 10000);

    }

    function handleRealtimeQueryResponse(response) {

        // If there was no data, do nothing
        if (!response) return;

        if (response["data"]) {
            var rt_hc_data = jQuery.parseJSON(response["data"].replace(/\bNaN\b/g, "null"));
        }
        else {
            console.debug('No new data available yet ...');
            return;
        }

        // If the returned data series is empty .. do nothing
        if ( typeof rt_hc_data == "undefined" || rt_hc_data == null || rt_hc_data.length == 0) return;
        if (rt_hc_data[0]["data"].length < 1) return;

        // replace names with display names
        use_display_names_in_data(rt_hc_data);

        // Remove series that were marked visible == false. probably string content
        //remove_unchartable_hc_data(rt_hc_data);

        // Collect all the real-time data in a separate series. Append new data
        if (data_series_rt.length > 0) {

            for (var i=0; i < data_series_rt.length; i++) {
                data_series_rt[i]["data"].push.apply(data_series_rt[i]["data"],rt_hc_data[i]["data"]);
            }
        }
        else {
            data_series_rt = rt_hc_data;
        }

        // Merge the overview, hi-res and realtime all together before redrawing the chart.
        // NEED TO FIX this expensive operation

        // EXception to the chart draw is if the current view is set to table. In this case, its an annoying
        // refresh that resets the table and does not need to be done.
        if (!(curr_chart_type == "table")) {
            drawChart(false, mergeAndSortHcData(data_series_overview, data_series_hires, data_series_rt));
            //console.debug("Num of data points in the chart :" + chart.series[0].data.length);
        }

        // if we have collected too much real-time data, flush and retrieve a low-res overview again
        if (data_series_rt[0]["data"].length > rt_len_max) {
            data_series_rt = [];
            initOverview();
        }

        // stop spinner
        //chart_spinner.stop();

    }

    function toggleRealtimeView(chkbox) {
        if (chkbox.checked) {
            startRealtimeView(chkbox);
            // Also refresh overview at the same time otherwise we will have a gap of empty datapoints
            initOverview();
        }
        else {
            stopRealtimeView();
        }
    }

    function startRealtimeView(chkbox) {
        rt_query = null;

        if ("rt_query_token" in sessionStorage) {
            rt_query_token = sessionStorage["rt_query_token"];
            stopRealtimeView();
        }

        // If there are more parameters thn the graph can handle, do not enable realtime view
        if (chart.series.length > max_supported_parameters_rt) {
            alert("This data product has over " + max_supported_parameters_rt + " parameters. Realtime view is not supported. Will update chart with latest data.");
            chkbox.checked = false;
            return;
        }

        initRealtimeView();
    }

    function stopRealtimeView() {

        // Stop the automatic query
        if (rt_query) {
            clearInterval(rt_query);
        }

        chart_spinner.stop();

        // call terminate on the container side too
        // terminate the realtime queues on the server side
        if (rt_query_token && rt_query_token != null && rt_query_token != "null") {

            console.debug ("Terminating queues associated with token : " + rt_query_token);
            jQuery.ajax ({
                url: container_server + "/visualization/terminate_realtime_visualization_data/?query_token=" + rt_query_token,
                dataType: 'json',
                success: function(response) {
                    console.debug("Real-time Termination acknowledged:" + response);
                },
                async: false
            });

            rt_query_token = sessionStorage["rt_query_token"] = null;
        }
        console.debug ("Done");
    }


    function initChartUi() {

        // Empty anything in the div before drawing
        $("#chart_ui_div").empty();

        // Populate UI components. Start with the list of parameters. Enclose in a container
        var chartUiDiv = document.getElementById("chart_ui_div");
        var chkBox, paramIdx, chart_type_select, id_str, y_axis_compare_type_select;

        // Create a select box for choosing the chart type
        chartUiDiv.appendChild(document.createTextNode('   Chart Type: '));
        chart_type_select = document.createElement('select');
        chart_type_select.setAttribute("id", "chart_type_select");
        chart_type_select.setAttribute("onChange", "onChartTypeChange(this)");

        var selectFlag = true;
        for (var i=0; i<supported_chart_type.length; i++) {
            chart_type_select.options[i] = new Option(supported_chart_type[i], supported_chart_type[i], selectFlag, false);
            selectFlag = false; // just need it true for the first entry
        }
        chartUiDiv.appendChild(chart_type_select);

        // Create a select box for choosing the comparison type
        chartUiDiv.appendChild(document.createTextNode('   Show Y-Axis As : '));
        y_axis_compare_type_select = document.createElement('select');
        y_axis_compare_type_select.setAttribute("id", "y_axis_compare_type_select");
        y_axis_compare_type_select.setAttribute("onChange", "onYaxisCompareTypeChange(this)");

        y_axis_compare_type_select.options[0] = new Option("Actual Values", undefined, true, false);
        y_axis_compare_type_select.options[1] = new Option("Value Comparison", "value", false, false);
        y_axis_compare_type_select.options[2] = new Option("Percentage Comparison", "percent", false, false);
        chartUiDiv.appendChild(y_axis_compare_type_select);

        // Create the 'set all' and 'clear all' button
        var check_all_viz_params_button = document.createElement('input');
        check_all_viz_params_button.type = 'button';
        check_all_viz_params_button.value = "Select All Parameters";
        check_all_viz_params_button.addEventListener("click", showAllVizParams);
        chartUiDiv.appendChild(check_all_viz_params_button);

        var clear_all_viz_params_button = document.createElement('input');
        clear_all_viz_params_button.type = 'button';
        clear_all_viz_params_button.value = "De-select All Parameters";
        clear_all_viz_params_button.addEventListener("click", hideAllVizParams);
        chartUiDiv.appendChild(clear_all_viz_params_button);
        //chartUiDiv.appendChild(document.createElement('br'));



        // Create a select box for choosing the chart type
        chartUiDiv.appendChild(document.createTextNode('   Output Type: '));
        output_type_select = document.createElement('select');
        output_type_select.setAttribute("id", "output_type_select");
        output_type_select.setAttribute("onChange", "onOutputTypeChange(this)");

        var selectFlag = true;
        for (var i=0; i<supported_output_type.length; i++) {
            output_type_select.options[i] = new Option(supported_output_type[i], supported_output_type[i], selectFlag, false);
            selectFlag = false; // just need it true for the first entry
        }
        chartUiDiv.appendChild(output_type_select);


        var generate_erddap_link = document.createElement('input');
        generate_erddap_link.type = 'button';
        generate_erddap_link.value = "Download";
        generate_erddap_link.addEventListener("click", generateLink);
        chartUiDiv.appendChild(generate_erddap_link);

        // Page reload button
        //chartUiDiv.appendChild(document.createElement('br'));
        var page_reload_button = document.createElement('input');
        page_reload_button.type = 'button';
        page_reload_button.value = "Refresh Chart";
        page_reload_button.align = "right";
        page_reload_button.addEventListener("click", reloadChart);
        chartUiDiv.appendChild(page_reload_button);

        // Realtime view check box. Draw only if enabled
        if (enable_realtime) {
            var rt_view_chkbox = document.createElement('input');
            rt_view_chkbox.type = 'checkbox';
            rt_view_chkbox.id = "rt_view_chkbox";
            rt_view_chkbox.setAttribute("onClick", "toggleRealtimeView(this)")
            var newlabel = document.createElement("Label");
            newlabel.setAttribute("for",rt_view_chkbox);
            newlabel.innerHTML = "Show Realtime Data";
            chartUiDiv.appendChild(rt_view_chkbox);
            chartUiDiv.appendChild(newlabel);
        }
    }

    function generateLink() {
        var urlIdx = parent.MODEL_DATA.computed.data_url.value.lastIndexOf("/");
        var erddapString = parent.MODEL_DATA.computed.data_url.value.substring(0,urlIdx+1);

        var fieldList = [];
        fieldList.push("?");
        fieldList.push("time");

        console.log('generate url');
        console.log(curr_parameter_visibility);

         var field;
        // check visibility flags for all the series
        for (var i = 0; i < chart.series.length - 1; i++) {
             field = [chart.series[i]["name"]];             
            // if the entry is visible add it to the list
            if (curr_parameter_visibility[field]){
                //console.log("true");
                console.log(field[0])
                var fieldName = field[0];
                console.log(display_names_reverse[fieldName]);
                //grab actual data name
                fieldList.push(display_names_reverse[fieldName]);

            }
        }
        //add time bounds
        //fieldList.push("&");
        //fieldList.push("time");
        //fieldList.push(">=");
        //curr_parameter_visibility, dp_metadata
        var id = parent.MODEL_DATA._id;
        var queryString = erddapString+id+curr_output_type;
        for (var i = 0; i < fieldList.length ; i++) {
            queryString = queryString+fieldList[i];
            if (i>0 && i<fieldList.length-1){
               queryString=queryString+",";
            }
        }
        queryString =queryString + "&orderBy(%22time%22)";
        console.log(queryString);
        window.open(queryString);
    }

     function onOutputTypeChange (selectedOption ) {
        console.log("update to the putput type");
        curr_output_type = selectedOption.value;        
    }

    function showAllVizParams() {
        // Show spinner
        chart_spinner.spin(spin_target);

        // Use settimeout to give the spinner a chance to show
        setTimeout(function(){
            for (var i=0; i < chart.series.length - 1; i++) {
                chart.series[i].show();
            }
            chart_spinner.stop();
        }, 100);
    }

    function hideAllVizParams() {
        // Show spinner
        chart_spinner.spin(spin_target);

        // Use settimeout to give the spinner a chance to show
        setTimeout(function(){
            for (var i=0; i < chart.series.length - 1; i++) {
                chart.series[i].hide();
            }
            chart_spinner.stop();
        }, 100);
    }

    function onChartTypeChange (selectedOption ) {

        // Show spinner
        chart_spinner.spin(spin_target);

        curr_chart_type = selectedOption.value;

        // Re-draw chart with new options. Use setTimeout to give the spinner a chance to show
        setTimeout(function(){
            drawChart(true, mergeAndSortHcData(data_series_overview, data_series_hires, data_series_rt));
            chart_spinner.stop();
        }, 100);
    }

    function onYaxisCompareTypeChange(selectedOption) {

        // Show spinner
        chart_spinner.spin(spin_target);

        curr_y_axis_compare_type = selectedOption.value;

        // Does not pass undefined as an object but a string .. wtf
        if (curr_y_axis_compare_type == "undefined") {
            curr_y_axis_compare_type = undefined;
        }

        if (curr_y_axis_compare_type == "percent") {
            alert("For percentage comparison, please disable any data series with zero-values, using the legend.");
        }

        // Re-draw chart with new options
        setTimeout(function(){
            drawChart(true, mergeAndSortHcData(data_series_overview, data_series_hires, data_series_rt));
            chart_spinner.stop();
        }, 100);
    }

    function reloadChart() {
        initOverview();
    }

    function chartCleanup() {
        stopRealtimeView();
    }



    function onDateRangeChange(e) {

        chart_visible_start_date = e.min;
        chart_visible_end_date = e.max;

        // Weird behavior. Sometimes the start and end date are same
        if (chart_visible_start_date >= chart_visible_end_date) {
            console.debug("Chart's start date should be less than the end date");
            return;
        }

        // detect if we need to stick view to the new realtime data
        // This will be done in terms of pixels and the sticky-ness is enabled if the view window is withing 1-2 pixels
        // of the end
        var xDataMin = chart.xAxis[0].getExtremes().dataMin;
        var xDataMax = chart.xAxis[0].getExtremes().dataMax;
        var xAxisPixels = chart.xAxis[0].width
        var viewWinMaxPixels = (chart_visible_end_date - xDataMin) * xAxisPixels / (xDataMax - xDataMin);

        // If view window position is within a couple of pixels of the right end, raise the sticky window flag
        if ((xAxisPixels - viewWinMaxPixels) <= 3) realtime_sticky_view = true;
        else
            realtime_sticky_view = false;

        // Try to detect if this method call was due to the sliding window effect. If yes, return
        if (realtime_sticky_view && setExtremesMethodFlag) {
            setExtremesMethodFlag = false;
            return;
        }

        // If the overview itself is at a high enough zoom level, no need to make requests for data
        if (data_overview_stride_factor == 1)
            return;

        // calculate current stride_factor
        var num_of_actual_data_points = (chart_visible_end_date - chart_visible_start_date) * avg_data_rate / 1000;
        curr_stride_factor = Math.ceil(num_of_actual_data_points / chart_x_res);
        console.debug ("curr_stride_factor : ", curr_stride_factor);

        // If we are still at the overview level, do nothing
        if (curr_stride_factor == data_overview_stride_factor)
            return;

        var adjusted_start_date = chart_visible_start_date;
        var adjusted_end_date = chart_visible_end_date;

        // Since the real-time data is always full res, we do not need to fetch it again. Basically adjust the
        // data query to reflect only the pieces needed for the hi-res retrieve
        if (data_series_rt.length > 0) {
            if (adjusted_start_date >= data_series_rt[0]["data"][0][0]) return; // view window is within real-time data
            // truncate the fetch window to the start of the real-time data
            if (adjusted_end_date > data_series_rt[0]["data"][0][0]) {
                adjusted_end_date = data_series_rt[0]["data"][0][0];
            }
        }

        var dqp = setDataQueryParams("highcharts_data", dp_parameters,
                Math.round(adjusted_start_date/1000),
                Math.round(adjusted_end_date/1000),
                curr_stride_factor);
        fetchData(dqp);


    }

    function setDataQueryParams(_query_type, _dt_params, _start_time, _end_time, _stride_factor) {

        // prep the dictionary as a string of value : key comma separated list
        var dq_params = {};
        dq_params['query_type'] = _query_type; // google_dt, mpl_image, metadata.
                                            // This parameter helps the service decide which internal handler to call
        dq_params['parameters'] = _dt_params; // Comma separated list of variables to be plotted. If empty,
        // all variables are plotted

        dq_params["start_time"] = _start_time;
        dq_params["end_time"] = _end_time;
        dq_params['stride_time'] = _stride_factor;

        dq_params['use_direct_access'] = 0;  // 1 for yes, 0 for no

        return dq_params;
    }

    function initSpinner() {
        var opts = {
            lines: 11, // The number of lines to draw
            length: 2, // The length of each line
            width: 12, // The line thickness
            radius: 25, // The radius of the inner circle
            corners: 0.7, // Corner roundness (0..1)
            rotate: 30, // The rotation offset
            color: "#999999", // #rgb or #rrggbb
            speed: 1.3, // Rounds per second
            trail: 54, // Afterglow percentage
            shadow: true, // Whether to render a shadow
            hwaccel: false, // Whether to use hardware acceleration
            className: 'spinner', // The CSS class to assign to the spinner
            zIndex: 2e9, // The z-index (defaults to 2000000000)
            top: 'auto', // Top position relative to parent in px
            left: 'auto' // Left position relative to parent in px
        };

        chart_spinner = new Spinner(opts);
    }

    </script>
  </head>

  <div class='chart-google' style="position:relative;">
      <div id="chart_div" style="width:100%;height:300px;"></div>
      <!-- <form> -->
      <div id="chart_ui_div" style=""></div>
      <!-- </form> -->
  </div>




  <!-- HTML code and UI components etc -->

